{
  "hash": "ccb80146f8fb334da6c244a7d5dc7486",
  "result": {
    "engine": "jupyter",
    "markdown": "# Logistic regression \n\nLogistic regression is very similar to linear regression, but applied to classification problems. In this chpater our idea is to treat it as the simplest example of a neural network instead of using other methods. The code we developped in the last chapter will be used extensively.\n\n<!-- \nConsider a set of training data $(x^{(1)}, y^{(1)}), (x^{(2)}, y^{(2)}), \\ldots$, where $x^{(i)}=(x^{(i)}_1, x^{(i)}_2, \\ldots, x^{(i)}_n)$ is a $n$-dim vector, and $y^{(i)}$ is a real number. We would like to use Linear regression to find the relation between $x$ and $y$. \n\nIn this case, we assume that $y$ is a linear function of $x$:\n\n$$\ny=\\theta_0 + \\sum_{j=1}^n\\theta_jx_j.\n$$\nThe purpose of Linear regression is to used the given training data to find out the best $\\Theta=(\\theta_0, \\theta_1, \\theta_2,\\ldots,\\theta_n)$. \n\nIf we set $\\hat{x}=(1, x_1, \\ldots,x_n)$, then the above formula can be reformulated by matrix multiplication.\n\n$$\ny=\\Theta \\hat{x}^T.\n$$\n\nWhen we want to deal with classification problem, we may still use this regression idea, but we have to do some modification.\n -->\n\n\n\n\n\n\n\n## Basic idea\n\nAssume that we have a binary classfification problem with $N$ features. Our model starts from the *logit* instead of the label $y$ itself.\n\n$$\nlogit(y)=\\theta_0+\\sum_{j=1}^N\\theta_jx_j.\n$$\n\nThe logit function is used to describe the logorithm of the binary odds. The odd ratio is the ratio between the probability of success and the probability of failure. Assume the probability of success is $p$. Then \n\n$$\noddratio(p)=\\frac{p}{1-p},\\quad logit(p)=z = \\log\\qty(\\frac{p}{1-p}).\n$$\nWe could solve the logit function, and get its inverse: the function is the *Sigmoid* function. Once we have the logit value, we could use it to get the probability. \n$$\np=\\sigma(z)=\\frac{1}{1+\\mathrm{e}^{-z}}.\n$$\n<!-- \nThe Logsitic regression is used to predict the probability of a data point belonging to a specific class. It is based on linear regression. The major difference is that logistic regreesion will have an activation function $\\sigma$ at the final stage to change the predicted values of the linear regression to the values that indicate classes. In the case of binary classification, the outcome of $\\sigma$ will be between $0$ and $1$, which is related to the two classes respectively. In this case, the number is interepted as the probability of the data to be in one of the specific class. -->\n\n\n\nTherefore the model for Logistic regression is as follows:\n\n$$\np=\\sigma(L(x))=\\sigma\\left(\\theta_0+\\sum_{j=1}^n\\theta_jx_j\\right)=\\sigma\\left(\\Theta \\hat{x}^T\\right).\n$$\n\n<!-- In most cases, this activation function is chosen to be the Sigmoid funciton. -->\n\n### Sigmoid function\n\nThe *Sigmoid* function is defined as follows:\n\n$$\n\\sigma(z)=\\frac{1}{1+\\mathrm{e}^{-z}}.\n$$\nThe graph of the function is shown below.\n\n::: {#48578c0c .cell execution_count=1}\n\n::: {.cell-output .cell-output-display}\n![](intro_files/figure-html/cell-2-output-1.png){width=571 height=411}\n:::\n:::\n\n\nThe main properties of $\\sigma$ are listed below as a Lemma.\n\n\n::: {#lem-sig}\n\nThe Sigmoid function $\\sigma(z)$ satisfies the following properties.\n\n1. $\\sigma(z)\\rightarrow \\infty$ when $z\\mapsto \\infty$.\n2. $\\sigma(z)\\rightarrow -\\infty$ when $z\\mapsto -\\infty$.\n3. $\\sigma(0)=0.5$.\n4. $\\sigma(z)$ is always increasing.\n5. $\\sigma'(z)=\\sigma(z)(1-\\sigma(z))$.\n\n:::\n\n\n\n::: {.solution}\nWe will only look at the last one.\n\n$$\n\\begin{split}\n\\sigma'(z)&=-\\frac{(1+\\mathrm e^{-z})'}{(1+\\mathrm e^{-z})^2}=\\frac{\\mathrm e^{-z}}{(1+\\mathrm e^{-z})^2}=\\frac{1}{1+\\mathrm e^{-z}}\\frac{\\mathrm e^{-z}}{1+\\mathrm e^{-z}}\\\\\n&=\\sigma(z)\\left(\\frac{1+\\mathrm e^{-z}}{1+\\mathrm e^{-z}}-\\frac{1}{1+\\mathrm e^{-z}}\\right)=\\sigma(z)(1-\\sigma(z)).\n\\end{split}\n$$\n:::\n\n\n\n### Gradient descent\n<!-- Assume that we would like to minimize a function $J(\\Theta)$, where this $\\Theta$ is an $N$-dim vector. Geometricly, we could treat $J$ as a height function, and it tells us the height of the mountain. Then to minimize $J$ is the same thing as to find the lowest point. One idea is to move towards the lowest point step by step. During each step we only need to lower our current height. After several steps we will be around the lowest point.\n\nThe geometric meaning of $\\nabla J$ is the direction that $J$ increase the most. Therefore the opposite direction is the one we want to move in. The formula to update $x$ is \n\n$$\n\\Theta_{\\text{new}} = \\Theta_{\\text{old}}-\\alpha \\nabla J(\\Theta_{\\text{old}}),\n$$\nwhere $\\alpha$ is called the *learning rate* which controls how fast you want to learn. Usually if $\\alpha$ is small, the learning tends to be slow and stble, and when $\\alpha$ is big, the learning tends to be fast and unstable. -->\n\n<!-- In machine learning, in most cases we would like to formulate the problem in terms of finding the lowest point of a *cost function* $J(\\Theta)$.  -->\n\nWe would like to use Gradient descent to sovle Logistic regression problems. For binary classification problem, the cost function is defined to be\n\n$$\nJ(\\Theta)=-\\frac1m\\sum_{i=1}^m\\left[y^{(i)}\\log(p^{(i)})+(1-y^{(i)})\\log(1-p^{(i)})\\right].\n$$\nHere $m$ is the number of data points, $y^{(i)}$ is the labelled result (which is either $0$ or $1$), $p^{(i)}$ is the predicted value (which is between $0$ and $1$). \n\n::: {.callout-note}\nThe algorithm gets its name since we are using the gradient to find a direction to lower our height. \n:::\n\n\n### The Formulas\n\n\n::: {#thm-reggrad}\nThe gradient of $J$ is computed by\n\n$$\n\\nabla J =\\frac1m(\\textbf{p}-\\textbf{y})^T\\hat{\\textbf{X}}.\n$$ {#eq-nablaJ}\n:::\n\n\n<details>\n<summary>Click for details.</summary>\n\n::: {.proof}\n\n\nThe formula is an application of the chain rule for the multivariable functions.\n\n$$\n\\begin{split}\n\\dfrac{\\partial p}{\\partial \\theta_k}&=\\dfrac{\\partial}{\\partial \\theta_k}\\sigma\\left(\\theta_0+\\sum_{j=1}^n\\theta_jx_j\\right)=\\dfrac{\\partial}{\\partial \\theta_k}\\sigma(L(\\Theta))\\\\\n&=\\sigma(L)(1-\\sigma(L))\\dfrac{\\partial}{\\partial \\theta_k}\\left(\\theta_0+\\sum_{j=1}^n\\theta_jx_j\\right)\\\\\n&=\\begin{cases}\np(1-p)&\\text{ if }k=0,\\\\\np(1-p)x_k&\\text{ otherwise}.\n\\end{cases}\n\\end{split}\n$$\nThen \n\n$$\n\\nabla p = \\left(\\frac{\\partial p}{\\partial\\theta_0},\\ldots,\\frac{\\partial p}{\\partial\\theta_n}\\right) = p(1-p)\\hat{x}.\n$$\n\nThen \n\n$$\n\\nabla \\log(p) = \\frac{\\nabla p}p =\\frac{p(1-p)\\hat{x}}{p}=(1-p)\\hat{x}.\n$$\n\n$$\n\\nabla \\log(1-p) = \\frac{-\\nabla p}{1-p} =-\\frac{p(1-p)\\hat{x}}{1-p}=-p\\hat{x}.\n$$\n\nThen \n\n$$\n\\begin{split}\n\\nabla J& = -\\frac1m\\sum_{i=1}^m\\left[y^{(i)}\\nabla \\log(p^{(i)})+(1-y^{(i)})\\nabla \\log(1-p^{(i)})\\right]\\\\\n&=-\\frac1m\\sum_{i=1}^m\\left[y^{(i)}(1-p^{(i)})\\hat{x}^{(i)}+(1-y^{(i)})(-p^{(i)}\\hat{x}^{(i)})\\right]\\\\\n&=-\\frac1m\\sum_{i=1}^m\\left[(y^{(i)}-p^{(i)})\\hat{x}^{(i)}\\right].\n\\end{split}\n$$\n\nWe write $\\hat{x}^{(i)}$ as row vectors, and stack all these row vectors vertically. What we get is a matrix $\\hat{\\textbf X}$ of the size $m\\times (1+n)$. We stack all $y^{(i)}$ (resp. $p^{(i)}$) vectically to get the $m$-dim column vector $\\textbf y$ (resp. $\\textbf p$). \n\nUsing this notation, the previous formula becomes\n\n\n$$\n\\nabla J =\\frac1m(\\textbf{p}-\\textbf{y})^T\\hat{\\textbf{X}}.\n$$\n\nAfter the gradient can be computed, we can start to use the gradient descent method. Note that, although $\\Theta$ are not explicitly presented in the formula of $\\nabla J$, this is used to modify $\\Theta$:\n\n$$\n\\Theta_{s+1} = \\Theta_s - \\alpha\\nabla J.\n$$\n\n:::\n</details>\n\n\n::: {.callout-note}\nIf you directly use library, like `sklearn` or `PyTorch`, they will handle the concrete computation of these gradients.\n:::\n\n\n\n## Regularization\n\n### Three types of errors\nEvery estimator has its advantages and drawbacks. Its generalization error can be decomposed in terms of bias, variance and noise. The **bias** of an estimator is its average error for different training sets. The **variance** of an estimator indicates how sensitive it is to varying training sets. Noise is a property of the data. \n\n\n### Underfit vs Overfit\n\nWhen fit a model to data, it is highly possible that the model is underfit or overfit. \n\nRoughly speaking, **underfit** means the model is not sufficient to fit the training samples, and **overfit** means that the models learns too many noise from the data. In many cases, high bias is related to underfit, and high variance is related to overfit.\n\nThe following example is from [the `sklearn` guide](https://scikit-learn.org/stable/auto_examples/model_selection/plot_underfitting_overfitting.html#sphx-glr-auto-examples-model-selection-plot-underfitting-overfitting-py). Although it is a polynomial regression example, it grasps the key idea of underfit and overfit.\n\n::: {#474e511b .cell .column-page execution_count=2}\n\n::: {.cell-output .cell-output-display}\n![](intro_files/figure-html/cell-3-output-1.png){width=1079 height=445}\n:::\n:::\n\n\n### Learning curves (accuracy vs training size)\n\nA learning curve shows the validation and training score of an estimator for varying a key hyperparameter. In most cases the key hyperparameter is the training size or the number of epochs. It is a tool to find out how much we benefit from altering the hyperparameter by training more data or training for more epochs, and whether the estimator suffers more from a variance error or a bias error. \n\n`sklearn` provides `sklearn.model_selection.learning_curve()` to generate the values that are required to plot such a learning curve. However this function is just related to the sample size. If we would like to talk about epochs, we need other packages.\n\nLet us first look at the learning curve about sample size. The official document page is [here](https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.learning_curve.html). The function takes input `estimator`, dataset `X`, `y`, and an arry-like argument `train_sizes`. The dataset `(X, y)` will be split into pieces using the cross-validation technique. The number of pieces is set by the argument `cv`. The default value is `cv=5`. For details about cross-validation please see @sec-cross-validation.\n\nThen the model is trained over a random sample of the training set, and evaluate the score over the test set. The size of the sample of the training set is set by the argument `train_sizes`. This argument is array-like. Therefore the process will be repeated several times, and we can see the impact of increasing the training size. \n\nThe output contains three pieces. The first is `train_sizes_abs` which is the number of elements in each training set. This output is mainly for reference. The difference between the output and the input `train_sizes` is that the input can be float which represents the percentagy. The output is always the exact number of elements.\n\nThe second output is `train_scores` and the third is `test_scores`, both of which are the scores we get from the training and testing process. Note that both are 2D `numpy` arrays, of the size `(number of different sizes, cv)`. Each row is a 1D `numpy` array representing the cross-validation scores, which is corresponding to a train size. If we want the mean as the cross-validation score, we could use `train_scores.mean(axis=1)`.\n\nAfter understanding the input and output, we could plot the learning curve. We still use the `horse colic` as the example. The details about the dataset can be found [here](https://xiaoxl.github.io/Datasets/contents/horse_colic.html).\n\n::: {#823ba8eb .cell execution_count=3}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n\nurl = 'http://archive.ics.uci.edu/ml/machine-learning-databases/horse-colic/horse-colic.data'\ndf = pd.read_csv(url, delim_whitespace=True, header=None)\ndf = df.replace(\"?\", np.NaN)\n\ndf.fillna(0, inplace=True)\ndf.drop(columns=[2, 24, 25, 26, 27], inplace=True)\ndf[23].replace({1: 1, 2: 0}, inplace=True)\nX = df.iloc[:, :-1].to_numpy().astype(float)\ny = df[23].to_numpy().astype(int)\n\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.15, random_state=42)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Local\\Temp\\ipykernel_32684\\73942173.py:5: FutureWarning: The 'delim_whitespace' keyword in pd.read_csv is deprecated and will be removed in a future version. Use ``sep='\\s+'`` instead\n  df = pd.read_csv(url, delim_whitespace=True, header=None)\nC:\\Users\\Xinli\\AppData\\Local\\Temp\\ipykernel_32684\\73942173.py:10: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method.\nThe behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy.\n\nFor example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object.\n\n\n  df[23].replace({1: 1, 2: 0}, inplace=True)\n```\n:::\n:::\n\n\nWe use the model `LogisticRegression`. The following code plot the learning curve for this model.\n\n::: {#6cd69a07 .cell execution_count=4}\n``` {.python .cell-code}\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.pipeline import Pipeline\n\nclf = LogisticRegression(max_iter=1000)\nsteps = [('scalar', MinMaxScaler()),\n         ('log', clf)]\npipe = Pipeline(steps=steps)\nfrom sklearn.model_selection import learning_curve\nimport numpy as np\ntrain_sizes, train_scores, test_scores = learning_curve(pipe, X_train, y_train,\n                                                        train_sizes=np.linspace(0.1, 1, 20))\n\nimport matplotlib.pyplot as plt\nplt.plot(train_sizes, train_scores.mean(axis=1), label='train')\nplt.plot(train_sizes, test_scores.mean(axis=1), label='test')\nplt.legend()\n```\n\n::: {.cell-output .cell-output-display}\n![](intro_files/figure-html/cell-5-output-1.png){width=579 height=411}\n:::\n:::\n\n\nThe learning curve is a primary tool for us to study the bias and variance. Usually\n\n- If the two training curve and the testing curve are very close to each other, this means that the variance is low. Otherwise the variance is high, and this means that the model probabily suffer from overfitting. \n- If the absolute training curve score is high, this means that the bias is low. Otherwise the bias is high, and this means that the model probabily suffer from underfitting.\n\nIn the above example, although regularization is applied by default, you may still notice some overfitting there.\n\n\n### Regularization\nRegularization is a technique to deal with overfitting. Here we only talk about the simplest method: ridge regression, also known as Tikhonov regularizaiton. Because of the formula given below, it is also called *$L_2$ regularization*. The idea is to add an additional term $\\dfrac{\\alpha}{2m}\\sum_{i=1}^m\\theta_i^2$ to the original cost function. When training with the new cost function, this additional term will force the parameters in the original term to be as small as possible. After finishing training, the additional term will be dropped, and we use the original cost function for validation and testing. Note that in the additional term $\\theta_0$ is not presented.\n\nThe hyperparameter $\\alpha$ is the *regularization strength*. If $\\alpha=0$, the new cost function becomes the original one; If $\\alpha$ is very large, the additional term dominates, and it will force all parameters to be almost $0$. In different context, the regularization strength is also given by $C=\\dfrac{1}{2\\alpha}$, called *inverse of regularization strength*.\n\n\n#### The math of regularization\n\n\n\n\n::: {#thm-ridgegrad}\nThe gradient of the ridge regression cost function is\n\n$$\n\\nabla J=\\frac1m(\\textbf{p}-\\textbf{y})^T\\hat{\\textbf{X}}+\\frac{\\alpha}{m}\\Theta.\n$$\n\nNote that $\\Theta$ doesn't contain $\\theta_0$, or you may treat $\\theta_0=0$.\n\n:::\n\nThe computation is straightforward.\n\n#### The code\n\nRegularization is directly provided by the logistic regression functions.\n\n- In `LogisticRegression`, the regularization is given by the argument `penalty` and `C`. `penalty` specifies the regularizaiton method. It is `l2` by default, which is the method above. `C` is the inverse of regularization strength, whose default value is `1`.\n- In `SGDClassifier`, the regularization is given by the argument `penalty` and `alpha`. `penalty` is the same as that in `LogisticRegression`, and `alpha` is the regularization strength, whose default value is `0.0001`.\n\nLet us see the above example.\n\n::: {#a7a3eca7 .cell execution_count=5}\n``` {.python .cell-code}\nclf = LogisticRegression(max_iter=1000, C=0.1)\nsteps = [('scalar', MinMaxScaler()),\n         ('log', clf)]\npipe = Pipeline(steps=steps)\nfrom sklearn.model_selection import learning_curve\nimport numpy as np\ntrain_sizes, train_scores, test_scores = learning_curve(pipe, X_train, y_train,\n                                                        train_sizes=np.linspace(0.1, 1, 20))\n\nimport matplotlib.pyplot as plt\nplt.plot(train_sizes, train_scores.mean(axis=1), label='train')\nplt.plot(train_sizes, test_scores.mean(axis=1), label='test')\nplt.legend()\n```\n\n::: {.cell-output .cell-output-display}\n![](intro_files/figure-html/cell-6-output-1.png){width=588 height=411}\n:::\n:::\n\n\nAfter we reduce `C` from `1` to `0.1`, the regularization strength is increased. Then you may find that the gap between the two curves are reduced. However the overall performace is also reduced, from 85%~90% in `C=1` case to around 80% in `C=0.1` case. This means that the model doesn't fit the data well as the previous one. Therefore this is a trade-off: decrease the variance but increase the bias.\n\n\n## Neural network implement of Logistic regression\nIn the previous sections, we use gradient descent to run the Logistic regression model. We mentioned some important concepts, like epochs, mini-batch, etc.. We are going to use `PyTorch` to implement it. We will reuse many codes we wrote in the previous chapter.\n<!-- \n### A simple example\n\nWe \n\n$$f(x)$$ -->\n\n\n\n### Example\n\nWe still use the horse colic dataset as an example. We first prepare the dataset.\n\n::: {#15c31d5e .cell execution_count=6}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\n\nurl = 'http://archive.ics.uci.edu/ml/machine-learning-databases/horse-colic/horse-colic.data'\ndf = pd.read_csv(url, sep='\\\\s+', header=None)\ndf = df.replace(\"?\", np.NaN)\n\ndf.fillna(0, inplace=True)\ndf = df.drop(columns=[2, 24, 25, 26, 27])\ndf[23] = df[23].replace({1: 1, 2: 0})\nX = df.iloc[:, :-1].to_numpy().astype(float)\ny = df[23].to_numpy().astype(int)\n\nSEED = 42\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.15, random_state=SEED)\n```\n:::\n\n\nWe need to perform normalization before throwing the data into the model. Here we use the `MinMaxScaler()` from `sklearn` package. \n\n::: {#e175e4af .cell execution_count=7}\n``` {.python .cell-code}\nfrom sklearn.preprocessing import MinMaxScaler\nmms = MinMaxScaler()\nX_train = mms.fit_transform(X_train, y_train)\nX_test = mms.transform(X_test)\n```\n:::\n\n\nThen we write a `Dataset` class to build the dataset and create the dataloaders. Since the set is already split, we don't need to `random_split` here.\n\n::: {#beab79cc .cell execution_count=8}\n``` {.python .cell-code}\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\n\nclass MyData(Dataset):\n    def __init__(self, X, y):\n        self.X = torch.tensor(X, dtype=float)\n        self.y = torch.tensor(y, dtype=float).reshape(-1, 1)\n\n    def __getitem__(self, index):\n        return (self.X[index], self.y[index])\n\n    def __len__(self):\n        return len(self.y)\n\n\ntrain_set = MyData(X_train, y_train)\nval_set = MyData(X_test, y_test)\n\ntrain_loader = DataLoader(train_set, batch_size=32, shuffle=True)\nval_loader = DataLoader(val_set, batch_size=32)\n```\n:::\n\n\n\n\nIn the following code, we first set up the original model.\n\n::: {#3629969c .cell execution_count=10}\n``` {.python .cell-code}\nimport torch.nn as nn\nfrom torch.nn.modules import Linear\n\nclass LoR(nn.Module):\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(*args, **kwargs)\n        self.linear = Linear(in_features=22, out_features=1, dtype=float)\n        self.activation = nn.Sigmoid()\n\n    def forward(self, X):\n        # pred = self.activation(self.linear(X))\n        pred = self.linear(X)\n        # return (pred >= 0).float()\n        return pred\n```\n:::\n\n\nThen we derive the base `ModelTemplate` class.\n\n::: {#5563d743 .cell execution_count=11}\n``` {.python .cell-code}\nclass LoRModel(ModelTemplate):\n    def __init__(self, model, loss_fn, optimizer):\n        super().__init__(model, loss_fn, optimizer)\n        self.stats['acc_train'] = []\n        self.stats['acc_val'] = []\n\n    def compute_acc(self, dataloader):\n        with torch.no_grad():\n            acc = []\n            for X_batch, y_batch in dataloader:\n                yhat = torch.sigmoid(self.model(X_batch))\n                y_pred = (yhat>=0.5).to(float)\n                acc.append((y_pred==y_batch).sum().item())\n            # print(acc_train)\n        return np.sum(acc)/len(dataloader.dataset)\n\n    def log_update(self, train_time, loss, val_time, val_loss, train_loader, val_loader):\n        super().log_update(train_time, loss, val_time, val_loss, train_loader, val_loader)\n        acc_train = self.compute_acc(train_loader)\n        acc_val = self.compute_acc(val_loader)\n        self.stats['acc_train'].append(acc_train)\n        self.stats['acc_val'].append(acc_val)\n\n\n        # p = self.model.state_dict()\n        # self.stats['acc'].append([p['linear.bias'].item(), p['linear.weight'].item()])\n\n    def log_output(self, verbose=0):\n        s = super().log_output(verbose=0, formatstr=':.6f')\n        s.append(f'acc_train: {self.stats['acc_train'][-1]:.6f}')\n        s.append(f'acc_val: {self.stats['acc_val'][-1]:.6f}')\n        # s.append(f'p: [{self.stats['p'][-1][0]:.6f}, {self.stats['p'][-1][1]:.6f}]')\n        if verbose == 1:\n            print(' '.join(s))\n        return s\n```\n:::\n\n\n::: {#afbc2a6c .cell execution_count=12}\n``` {.python .cell-code}\nfrom torch.optim import SGD\nfrom torch.nn import BCEWithLogitsLoss, BCELoss\n\noriginal_model = LoR()\nmodel = LoRModel(model=original_model, loss_fn=BCEWithLogitsLoss(),\n                 optimizer=SGD(original_model.parameters(), lr = 0.1))\n\nmodel.train(train_loader, val_loader, epoch_num=100, verbose=1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nepoch 1 train_time: 0.012002 loss: 0.660165 val_time: 0.000999 val_loss: 0.586527 acc_train: 0.631373 acc_val: 0.711111\nepoch 2 train_time: 0.007004 loss: 0.632877 val_time: 0.002000 val_loss: 0.574789 acc_train: 0.639216 acc_val: 0.711111\nepoch 3 train_time: 0.006922 loss: 0.618968 val_time: 0.000000 val_loss: 0.557177 acc_train: 0.635294 acc_val: 0.711111\nepoch 4 train_time: 0.007000 loss: 0.608678 val_time: 0.001000 val_loss: 0.550046 acc_train: 0.647059 acc_val: 0.711111\nepoch 5 train_time: 0.008202 loss: 0.600945 val_time: 0.000949 val_loss: 0.543118 acc_train: 0.635294 acc_val: 0.711111\nepoch 6 train_time: 0.008081 loss: 0.593400 val_time: 0.001000 val_loss: 0.537980 acc_train: 0.654902 acc_val: 0.711111\nepoch 7 train_time: 0.006731 loss: 0.585208 val_time: 0.002093 val_loss: 0.536863 acc_train: 0.674510 acc_val: 0.733333\nepoch 8 train_time: 0.007899 loss: 0.577833 val_time: 0.000999 val_loss: 0.532986 acc_train: 0.690196 acc_val: 0.733333\nepoch 9 train_time: 0.005000 loss: 0.572980 val_time: 0.001001 val_loss: 0.532861 acc_train: 0.717647 acc_val: 0.711111\nepoch 10 train_time: 0.006002 loss: 0.566206 val_time: 0.001001 val_loss: 0.527841 acc_train: 0.713725 acc_val: 0.711111\nepoch 11 train_time: 0.007473 loss: 0.560728 val_time: 0.000997 val_loss: 0.522415 acc_train: 0.717647 acc_val: 0.711111\nepoch 12 train_time: 0.008002 loss: 0.555968 val_time: 0.000998 val_loss: 0.519069 acc_train: 0.717647 acc_val: 0.711111\nepoch 13 train_time: 0.007010 loss: 0.551708 val_time: 0.002008 val_loss: 0.519409 acc_train: 0.745098 acc_val: 0.711111\nepoch 14 train_time: 0.007998 loss: 0.547372 val_time: 0.002002 val_loss: 0.519123 acc_train: 0.752941 acc_val: 0.733333\nepoch 15 train_time: 0.005991 loss: 0.544968 val_time: 0.000000 val_loss: 0.515328 acc_train: 0.752941 acc_val: 0.733333\nepoch 16 train_time: 0.007001 loss: 0.538719 val_time: 0.001002 val_loss: 0.512927 acc_train: 0.756863 acc_val: 0.755556\nepoch 17 train_time: 0.006999 loss: 0.535396 val_time: 0.001000 val_loss: 0.510180 acc_train: 0.760784 acc_val: 0.755556\nepoch 18 train_time: 0.008028 loss: 0.531635 val_time: 0.000990 val_loss: 0.509192 acc_train: 0.760784 acc_val: 0.755556\nepoch 19 train_time: 0.009000 loss: 0.528633 val_time: 0.001999 val_loss: 0.508492 acc_train: 0.768627 acc_val: 0.755556\nepoch 20 train_time: 0.008018 loss: 0.524708 val_time: 0.001412 val_loss: 0.507157 acc_train: 0.764706 acc_val: 0.777778\nepoch 21 train_time: 0.008515 loss: 0.521868 val_time: 0.001011 val_loss: 0.504501 acc_train: 0.768627 acc_val: 0.777778\nepoch 22 train_time: 0.007004 loss: 0.518677 val_time: 0.001000 val_loss: 0.501269 acc_train: 0.772549 acc_val: 0.777778\nepoch 23 train_time: 0.005998 loss: 0.516936 val_time: 0.000000 val_loss: 0.505148 acc_train: 0.772549 acc_val: 0.777778\nepoch 24 train_time: 0.006999 loss: 0.513643 val_time: 0.000000 val_loss: 0.501260 acc_train: 0.772549 acc_val: 0.777778\nepoch 25 train_time: 0.006999 loss: 0.511099 val_time: 0.001005 val_loss: 0.498737 acc_train: 0.780392 acc_val: 0.777778\nepoch 26 train_time: 0.007002 loss: 0.509501 val_time: 0.001001 val_loss: 0.500423 acc_train: 0.780392 acc_val: 0.777778\nepoch 27 train_time: 0.007017 loss: 0.505988 val_time: 0.001982 val_loss: 0.500657 acc_train: 0.780392 acc_val: 0.777778\nepoch 28 train_time: 0.005007 loss: 0.504516 val_time: 0.000999 val_loss: 0.495599 acc_train: 0.780392 acc_val: 0.777778\nepoch 29 train_time: 0.008042 loss: 0.501767 val_time: 0.000999 val_loss: 0.497422 acc_train: 0.780392 acc_val: 0.777778\nepoch 30 train_time: 0.006001 loss: 0.499805 val_time: 0.001000 val_loss: 0.494277 acc_train: 0.784314 acc_val: 0.777778\nepoch 31 train_time: 0.005997 loss: 0.498464 val_time: 0.001000 val_loss: 0.496333 acc_train: 0.780392 acc_val: 0.755556\nepoch 32 train_time: 0.008000 loss: 0.495356 val_time: 0.000985 val_loss: 0.490543 acc_train: 0.784314 acc_val: 0.777778\nepoch 33 train_time: 0.006019 loss: 0.494053 val_time: 0.001000 val_loss: 0.492300 acc_train: 0.788235 acc_val: 0.755556\nepoch 34 train_time: 0.007984 loss: 0.491240 val_time: 0.000999 val_loss: 0.492885 acc_train: 0.776471 acc_val: 0.755556\nepoch 35 train_time: 0.007014 loss: 0.490160 val_time: 0.001991 val_loss: 0.491413 acc_train: 0.776471 acc_val: 0.755556\nepoch 36 train_time: 0.017107 loss: 0.488223 val_time: 0.004009 val_loss: 0.493107 acc_train: 0.772549 acc_val: 0.777778\nepoch 37 train_time: 0.006999 loss: 0.485914 val_time: 0.002000 val_loss: 0.490898 acc_train: 0.776471 acc_val: 0.777778\nepoch 38 train_time: 0.009995 loss: 0.484564 val_time: 0.001000 val_loss: 0.490955 acc_train: 0.772549 acc_val: 0.777778\nepoch 39 train_time: 0.009002 loss: 0.482808 val_time: 0.000999 val_loss: 0.489583 acc_train: 0.776471 acc_val: 0.777778\nepoch 40 train_time: 0.009010 loss: 0.481539 val_time: 0.000999 val_loss: 0.487595 acc_train: 0.776471 acc_val: 0.777778\nepoch 41 train_time: 0.007074 loss: 0.480344 val_time: 0.002008 val_loss: 0.489404 acc_train: 0.780392 acc_val: 0.800000\nepoch 42 train_time: 0.008464 loss: 0.478523 val_time: 0.001641 val_loss: 0.488327 acc_train: 0.784314 acc_val: 0.800000\nepoch 43 train_time: 0.008202 loss: 0.476778 val_time: 0.001057 val_loss: 0.490856 acc_train: 0.784314 acc_val: 0.777778\nepoch 44 train_time: 0.005875 loss: 0.475038 val_time: 0.001043 val_loss: 0.486832 acc_train: 0.784314 acc_val: 0.800000\nepoch 45 train_time: 0.008126 loss: 0.472883 val_time: 0.001042 val_loss: 0.484342 acc_train: 0.784314 acc_val: 0.800000\nepoch 46 train_time: 0.007999 loss: 0.472093 val_time: 0.000997 val_loss: 0.485877 acc_train: 0.784314 acc_val: 0.800000\nepoch 47 train_time: 0.009999 loss: 0.470641 val_time: 0.002001 val_loss: 0.485934 acc_train: 0.784314 acc_val: 0.800000\nepoch 48 train_time: 0.006997 loss: 0.470009 val_time: 0.000000 val_loss: 0.485674 acc_train: 0.780392 acc_val: 0.800000\nepoch 49 train_time: 0.006142 loss: 0.468147 val_time: 0.001002 val_loss: 0.484136 acc_train: 0.780392 acc_val: 0.800000\nepoch 50 train_time: 0.009053 loss: 0.466906 val_time: 0.002000 val_loss: 0.482787 acc_train: 0.780392 acc_val: 0.800000\nepoch 51 train_time: 0.008996 loss: 0.466078 val_time: 0.001000 val_loss: 0.483676 acc_train: 0.780392 acc_val: 0.800000\nepoch 52 train_time: 0.007037 loss: 0.465034 val_time: 0.001998 val_loss: 0.485045 acc_train: 0.780392 acc_val: 0.777778\nepoch 53 train_time: 0.009555 loss: 0.463907 val_time: 0.001000 val_loss: 0.482525 acc_train: 0.784314 acc_val: 0.777778\nepoch 54 train_time: 0.007005 loss: 0.461899 val_time: 0.001018 val_loss: 0.478441 acc_train: 0.780392 acc_val: 0.800000\nepoch 55 train_time: 0.006006 loss: 0.460972 val_time: 0.001007 val_loss: 0.477887 acc_train: 0.780392 acc_val: 0.800000\nepoch 56 train_time: 0.008001 loss: 0.459496 val_time: 0.001017 val_loss: 0.477387 acc_train: 0.780392 acc_val: 0.800000\nepoch 57 train_time: 0.007998 loss: 0.458561 val_time: 0.001002 val_loss: 0.478509 acc_train: 0.784314 acc_val: 0.800000\nepoch 58 train_time: 0.006000 loss: 0.458086 val_time: 0.001000 val_loss: 0.474418 acc_train: 0.788235 acc_val: 0.800000\nepoch 59 train_time: 0.008212 loss: 0.455597 val_time: 0.001000 val_loss: 0.475687 acc_train: 0.788235 acc_val: 0.800000\nepoch 60 train_time: 0.009000 loss: 0.455844 val_time: 0.001000 val_loss: 0.477320 acc_train: 0.788235 acc_val: 0.777778\nepoch 61 train_time: 0.009054 loss: 0.454108 val_time: 0.001000 val_loss: 0.475539 acc_train: 0.788235 acc_val: 0.777778\nepoch 62 train_time: 0.008001 loss: 0.453973 val_time: 0.000510 val_loss: 0.474032 acc_train: 0.792157 acc_val: 0.800000\nepoch 63 train_time: 0.006019 loss: 0.452113 val_time: 0.001980 val_loss: 0.473794 acc_train: 0.788235 acc_val: 0.777778\nepoch 64 train_time: 0.007982 loss: 0.452941 val_time: 0.001000 val_loss: 0.473315 acc_train: 0.792157 acc_val: 0.777778\nepoch 65 train_time: 0.007000 loss: 0.450552 val_time: 0.001998 val_loss: 0.474471 acc_train: 0.788235 acc_val: 0.755556\nepoch 66 train_time: 0.008997 loss: 0.449623 val_time: 0.000999 val_loss: 0.472488 acc_train: 0.792157 acc_val: 0.777778\nepoch 67 train_time: 0.009081 loss: 0.449486 val_time: 0.000000 val_loss: 0.478104 acc_train: 0.784314 acc_val: 0.777778\nepoch 68 train_time: 0.008004 loss: 0.448498 val_time: 0.001000 val_loss: 0.478637 acc_train: 0.780392 acc_val: 0.777778\nepoch 69 train_time: 0.004996 loss: 0.446566 val_time: 0.001504 val_loss: 0.473761 acc_train: 0.784314 acc_val: 0.755556\nepoch 70 train_time: 0.006984 loss: 0.446991 val_time: 0.000998 val_loss: 0.473666 acc_train: 0.784314 acc_val: 0.755556\nepoch 71 train_time: 0.005998 loss: 0.444544 val_time: 0.000000 val_loss: 0.472638 acc_train: 0.784314 acc_val: 0.755556\nepoch 72 train_time: 0.007997 loss: 0.444092 val_time: 0.001000 val_loss: 0.472773 acc_train: 0.784314 acc_val: 0.777778\nepoch 73 train_time: 0.007005 loss: 0.442510 val_time: 0.000999 val_loss: 0.471294 acc_train: 0.788235 acc_val: 0.777778\nepoch 74 train_time: 0.005983 loss: 0.442764 val_time: 0.000996 val_loss: 0.471654 acc_train: 0.784314 acc_val: 0.777778\nepoch 75 train_time: 0.007997 loss: 0.441092 val_time: 0.001001 val_loss: 0.472774 acc_train: 0.784314 acc_val: 0.777778\nepoch 76 train_time: 0.007032 loss: 0.440632 val_time: 0.002000 val_loss: 0.470745 acc_train: 0.784314 acc_val: 0.777778\nepoch 77 train_time: 0.009515 loss: 0.439981 val_time: 0.002000 val_loss: 0.473636 acc_train: 0.784314 acc_val: 0.777778\nepoch 78 train_time: 0.007997 loss: 0.440586 val_time: 0.001000 val_loss: 0.473777 acc_train: 0.784314 acc_val: 0.777778\nepoch 79 train_time: 0.006000 loss: 0.437244 val_time: 0.001000 val_loss: 0.470391 acc_train: 0.784314 acc_val: 0.777778\nepoch 80 train_time: 0.006000 loss: 0.437503 val_time: 0.002005 val_loss: 0.471904 acc_train: 0.784314 acc_val: 0.777778\nepoch 81 train_time: 0.009001 loss: 0.437036 val_time: 0.002004 val_loss: 0.468702 acc_train: 0.784314 acc_val: 0.777778\nepoch 82 train_time: 0.009023 loss: 0.436121 val_time: 0.000995 val_loss: 0.467339 acc_train: 0.788235 acc_val: 0.777778\nepoch 83 train_time: 0.007996 loss: 0.434761 val_time: 0.000000 val_loss: 0.469654 acc_train: 0.784314 acc_val: 0.777778\nepoch 84 train_time: 0.008003 loss: 0.434397 val_time: 0.001000 val_loss: 0.467646 acc_train: 0.788235 acc_val: 0.777778\nepoch 85 train_time: 0.007982 loss: 0.435121 val_time: 0.000000 val_loss: 0.470189 acc_train: 0.788235 acc_val: 0.777778\nepoch 86 train_time: 0.006992 loss: 0.432307 val_time: 0.002001 val_loss: 0.468117 acc_train: 0.784314 acc_val: 0.777778\nepoch 87 train_time: 0.005981 loss: 0.432906 val_time: 0.002000 val_loss: 0.471442 acc_train: 0.788235 acc_val: 0.777778\nepoch 88 train_time: 0.008082 loss: 0.430979 val_time: 0.001030 val_loss: 0.468135 acc_train: 0.788235 acc_val: 0.777778\nepoch 89 train_time: 0.007986 loss: 0.430308 val_time: 0.001106 val_loss: 0.466767 acc_train: 0.792157 acc_val: 0.777778\nepoch 90 train_time: 0.008506 loss: 0.429298 val_time: 0.002007 val_loss: 0.466248 acc_train: 0.792157 acc_val: 0.777778\nepoch 91 train_time: 0.007001 loss: 0.429577 val_time: 0.001001 val_loss: 0.466661 acc_train: 0.788235 acc_val: 0.777778\nepoch 92 train_time: 0.009002 loss: 0.428482 val_time: 0.002002 val_loss: 0.466210 acc_train: 0.792157 acc_val: 0.777778\nepoch 93 train_time: 0.007081 loss: 0.427814 val_time: 0.001001 val_loss: 0.466178 acc_train: 0.792157 acc_val: 0.777778\nepoch 94 train_time: 0.005005 loss: 0.428871 val_time: 0.001003 val_loss: 0.466175 acc_train: 0.788235 acc_val: 0.777778\nepoch 95 train_time: 0.006000 loss: 0.426396 val_time: 0.001000 val_loss: 0.464582 acc_train: 0.792157 acc_val: 0.777778\nepoch 96 train_time: 0.009004 loss: 0.426577 val_time: 0.001010 val_loss: 0.465821 acc_train: 0.792157 acc_val: 0.777778\nepoch 97 train_time: 0.005995 loss: 0.425446 val_time: 0.002000 val_loss: 0.462678 acc_train: 0.792157 acc_val: 0.777778\nepoch 98 train_time: 0.007984 loss: 0.424431 val_time: 0.000999 val_loss: 0.460735 acc_train: 0.796078 acc_val: 0.777778\nepoch 99 train_time: 0.006969 loss: 0.425304 val_time: 0.002006 val_loss: 0.461348 acc_train: 0.796078 acc_val: 0.777778\nepoch 100 train_time: 0.005995 loss: 0.423569 val_time: 0.000981 val_loss: 0.460811 acc_train: 0.796078 acc_val: 0.777778\n```\n:::\n:::\n\n\n<!-- {{< include pytorch.qmd >}} -->\n\n\n\n<!-- {{< include multi.qmd >}} -->\n\n\n<!-- {{< include sklearn.qmd >}} -->\n\n\n\n\n\n## Exercises and Projects\n\n\n\n::: {#exr-}\nPlease hand write a report about the details of the math formulas for Logistic regression.\n:::\n\n\n<!-- \n\n::: {#exr-}\nCHOOSE ONE: Please use `sklearn` to apply the LogisticRegression to one of the following datasets. You may either use `LogisticRegression` or `SGDClassifier`.\n\n- the `iris` dataset.\n- the dating dataset.\n- the `titanic` dataset.\n\nPlease in addition answer the following questions.\n\n1. What is your accuracy score?\n2. How many epochs do you use?\n3. Plot the learning curve (accuracy vs training sizes).\n::: -->\n\n\n\n::: {#exr-}\n\nCHOOSE ONE: Please use `PyTorch` to apply the LogisticRegression to one of the following datasets.\n\n- the `iris` dataset.\n- the dating dataset.\n- the `titanic` dataset.\n\nPlease in addition answer the following questions.\n\n1. What is your accuracy score?\n2. How many epochs do you use?\n3. What is the batch size do you use?\n4. Plot the learning curve (loss vs epochs, accuracy vs epochs).\n5. Analyze the bias / variance status.\n:::\n\n",
    "supporting": [
      "intro_files"
    ],
    "filters": [],
    "includes": {}
  }
}