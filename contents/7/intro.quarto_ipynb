{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Netural networks\n",
        "\n",
        "There are many different architects of netural networks. In our course we will only talk about the simplest one: multilayer perceptron (MLP). We will treat it as the generalization of logistic regression. In other words, we will treat logistic regression as an one-layer netural network. Under this idea, all the concepts and ideas, like gradient descent, mini-batch training, loss functions, learning curves, etc.. will be used. \n",
        "\n",
        "\n",
        "\n",
        "\n",
        "## Neural network: Back propagation\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "::: {.hidden}\n",
        "$$\n",
        "\\newcommand\\diffp[2]{\\dfrac{\\partial #1}{\\partial #2}}\n",
        "$$\n",
        ":::\n",
        "\n",
        "To train a MLP model, we still use gradient descent. Therefore it is very important to know how to compute the gradient. Actually the idea is the same as logistic regreesion. The only issue is that now the model is more complicated. The gradient computation is summrized as an algorithm called `back propagation`. It is described as follows.\n",
        "\n",
        "Here is an example of a Neural network with one hidden layer.\n",
        "\n",
        "![](assests/img/20221114232327.png)  \n",
        "\n",
        "    \n",
        "$\\Theta$ is the coefficients of the whole Neural network. \n",
        " \n",
        "\n",
        "\n",
        "- $a^{(1)}=\\hat{\\textbf{x}}$ is the input. $a_0^{(1)}$ is added. This is an $(n+1)$-dimension column vector.\n",
        "- $\\Theta^{(1)}$ is the coefficient matrix from the input layer to the hidden layer, of size $k\\times(n+1)$.\n",
        "- $z^{(2)}=\\Theta^{(1)}a^{(1)}$.\n",
        "- $a^{(2)}=\\sigma(z^{(2)})$, and then add $a^{(2)}_0$. This is an $(k+1)$-dimension column vector.\n",
        "- $\\Theta^{(2)}$ is the coefficient matrix from the hidden layer to the output layer, of size $r\\times(k+1)$.\n",
        "- $z^{(3)}=\\Theta^{(2)}a^{(2)}$.\n",
        "- $a^{(3)}=\\sigma(z^{(3)})$. Since this is the output layer, $a^{(3)}_0$ won't be added.\n",
        "    % \\item These $a^{(3)}$ are $h_{\\Theta}(\\textbf{x})$.\n",
        "\n",
        "\n",
        "The dependency is as follows:\n",
        "\n",
        "- $J$ depends on $z^{(3)}$ and $a^{(3)}$.\n",
        "- $z^{(3)}$ and $a^{(3)}$ depends on $\\Theta^{(2)}$ and $a^{(2)}$.\n",
        "- $z^{(2)}$ and $a^{(2)}$ depends on $\\Theta^{(1)}$ and $a^{(1)}$.\n",
        "- $J$ depends on $\\Theta^{(1)}$, $\\Theta^{(2)}$ and $a^{(1)}$.\n",
        "\n",
        "\n",
        "Each layer is represented by the following diagram:\n",
        "\n",
        "![](assests/img/20221114232354.png)  \n",
        "\n",
        "\n",
        "\n",
        "The diagram says:\n",
        "\n",
        "$$\n",
        "z^{(k+1)}=b^{(k)}+\\Theta^{(k)}a^{(k)},\\quad z^{(k+1)}_j=b^{(k)}_j+\\sum \\Theta^{(k)}_{jl}a^{(k)}_l,\\quad a^{(k)}_j=\\sigma(z^{(k)}_j).\n",
        "$$\n",
        "\n",
        "Assume $r,j\\geq1$. Then\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "\\diffp{z^{(k+1)}_i}{a^{(k)}_r}&=\\diffp*{\\left(b^{(k)}_i+\\sum\\Theta^{(k)}_{il}a^{(k)}_l\\right)}{a^{(k)}_r}=\\Theta_{ir}^{(k)},\\\\\n",
        "% \\diffp{z^{(k+1)}_i}{\\Theta^{(k)}_{ij}}&=\\diffp*{\\qty(a^{(k)}_0+\\sum\\Theta^{(k)}_{il}a^{(k)}_l)}{\\Theta^{(k)}_{ij}}=a^{(k)}_j,\\\\\n",
        "\\diffp{z^{(k+1)}_i}{z^{(k)}_j}&=\\sum_r \\diffp{z^{(k+1)}_i}{a^{k}_r}\\diffp{a^{(k)}_r}{z^{(k)}_j}+\\sum_{p,g}\\diffp{z^{(k+1)}_i}{\\Theta^{(k)}_{pq}}\\diffp{\\Theta^{(k)}_{pq}}{z^{(k)}_j}+\\sum_r \\diffp{z^{(k+1)}_i}{b^{k}_r}\\diffp{b^{(k)}_r}{z^{(k)}_j}\\\\\n",
        "&=\\sum_r \\Theta^{(k)}_{ir}\\diffp{a^{(k)}_r}{z^{(k)}_j}=\\Theta^{(k)}_{ij}\\diffp{a^{(k)}_j}{z^{(k)}_j}=\\Theta^{(k)}_{ij}\\sigma'(z^{(k)}_j),\\\\\n",
        "\\diffp{J}{z^{(k)}_j}&=\\sum_r \\diffp{J}{z^{(k+1)}_r}\\diffp{z^{(k+1)}_r}{z^{(k)}_j}=\\sum_r\\diffp{J}{z^{(k+1)}_r}\\Theta^{(k)}_{rj}\\sigma'(z^{(k)}_j).\n",
        "\\end{aligned}\n",
        "$$\n",
        "\n",
        "We set \n",
        "\n",
        "- $\\delta^k_j=\\diffp{J}{z^{(k)}_j}$, $\\delta^k=\\left[\\delta^k_1,\\delta_2^k,\\ldots\\right]^T$.\n",
        "- $\\mathbf{z}^k=\\left[z^{(k)}_1,z^{(k)}_2,\\ldots\\right]^T$, $\\mathbf{a}^k=\\left[a^{(k)}_1,a^{(k)}_2,\\ldots\\right]^T$,\n",
        "    $\\hat{\\mathbf{a}}^k=\\left[a^{(k)}_0,a^{(k)}_1,\\ldots\\right]^T$.\n",
        "- $\\Theta^{k}=\\left[\\Theta^{(k)}_{ij}\\right]$.\n",
        "\n",
        "Then we have the following formula. Note that there are ``$z_0$'' terms.\n",
        "\n",
        "$$\n",
        "    \\delta^k=\\left[(\\Theta^k)^T\\delta^{k+1}\\right]\\circ \\sigma'(\\mathbf{z}^k).\n",
        "$$\n",
        "\n",
        "\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "\\diffp{z^{(k+1)}_r}{\\Theta^{(k)}_{pq}}&=\\diffp*{\\left(b^{(k)}_r+\\sum_l\\Theta^{(k)}_{rl}a^{(k)}_l\\right)}{\\Theta^{(k)}_{pq}}=\\begin{cases}\n",
        "0&\\text{ for }r\\neq q,\\\\\n",
        "a^{(k)}_q&\\text{ for }r=q,\n",
        "\\end{cases}\\\\\n",
        "\\diffp{J}{\\Theta^{(k)}_{pq}}&=\\sum_{r}\\diffp{J}{z^{(k+1)}_r}\\diffp{z^{(k+1)}_r}{\\Theta^{(k)}_{pq}}=\\diffp{J}{z^{(k+1)}_p}\\diffp{z^{(k+1)}_p}{\\Theta^{(k)}_{pq}}=\\delta^{k+1}_pa^{k}_q,\\\\\n",
        "\\diffp{J}{b^{(k)}_{j}}&=\\sum_{r}\\diffp{J}{z^{(k+1)}_r}\\diffp{z^{(k+1)}_r}{b^{(k)}_{j}}=\\diffp{J}{z^{(k+1)}_j}\\diffp{z^{(k+1)}_j}{b^{(k)}_{j}}=\\diffp{J}{z^{(k+1)}_j}=\\delta^{k+1}_j.\n",
        "\\end{aligned}\n",
        "$$\n",
        "\n",
        "Extend $\\hat{\\Theta}=\\left[b^{(k)},\\Theta^{(k)}\\right]$, and $\\partial^k J=\\left[\\diffp{J}{\\hat{\\Theta}^{(k)}_{ij}}\\right]$. Then\n",
        "$$\n",
        "    \\partial^k J=\\left[\\delta^{k+1}, \\delta^{k+1}(\\mathbf{a}^k)^T\\right].\n",
        "$$\n",
        "Then the algorithm is as follows.\n",
        "\n",
        "1. Starting from $x$, $y$ and some random $\\Theta$.\n",
        "1. Forward computation: compute $z^{(k)}$ and $a^{(k)}$. The last $a^{(n)}$ is $h$.\n",
        "1. Compute $\\delta^n=\\nabla J\\circ\\sigma'(z^{(n)})$. In the case of $J=\\frac12||{h-y}||^2$, $\\nabla J=(a^{(n)}-y)$, and then $\\delta^n=(a^{(n)}-y)\\circ\\sigma'(z^{(n)})$.\n",
        "1. Backwards: $\\delta^k=\\left[(\\Theta^k)^T\\delta^{k+1}\\right]\\circ \\sigma'(\\mathbf{z}^k)$, and $\\partial^k J=\\left[\\delta^{k+1}, \\delta^{k+1}(\\mathbf{a}^k)^T\\right]$ .\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "::: {#exm-}\n",
        "\n",
        "\n",
        "Consider there are 3 layers: input, hidden and output. There are $m+1$ nodes in the input layer, $n+1$ nodes in the hidden layer and $k$ in the output layer. Therefore\n",
        "\n",
        "- $a^{(1)}$ and $\\delta^1$ are $m$-dim column vectors.\n",
        "- $z^{(2)}$, $a^{(2)}$ and $\\delta^2$ are $n$-dim column vectors.\n",
        "- $z^{(3)}$, $a^{(3)}$ and $\\delta^3$ are $k$-dim column vectors.\n",
        "- $\\hat{\\Theta}^1$ is $n\\times(m+1)$, $\\hat{\\Theta}^2$ is $k\\times(n+1)$.\n",
        "- $z^{(2)}=b^{(1)}+\\Theta^{(1)}a^{(1)}=\\hat{\\Theta}^{(1)}\\hat{a}^{(1)}$, $z^{(3)}=b^{(2)}+\\Theta^{(2)}a^{(2)}=\\hat{\\Theta}^{(2)}\\hat{a}^{(2)}$.\n",
        "- $\\delta^3=\\nabla_aJ\\circ\\sigma'(z^{(3)})$. This is a $k$-dim column vector.\n",
        "- $\\partial^2 J=\\left[\\delta^3,\\delta^3(a^{(2)})^T\\right]$.\n",
        "- $\\delta^2=\\left[(\\Theta^2)^T\\delta^3\\right]\\circ \\sigma'(z^{(2)})$, where $(\\hat{\\Theta^2})^T\\delta^3=(\\hat{\\Theta^2})^T\\delta^3$ and then remove the first row.\n",
        "- $\\delta^1=\\begin{bmatrix}(\\Theta^1)^T\\delta^2\\end{bmatrix}\\circ \\sigma'(z^{(1)})$, where $(\\hat{\\Theta^1})^T\\delta^2=(\\hat{\\Theta^1})^T\\delta^2$ and then remove the first row.\n",
        "- $\\partial^1 J=\\left[\\delta^2,\\delta^2(a^{(1)})^T\\right]$.\n",
        "- When $J=-\\frac1m\\sum y\\ln a+(1-y)\\ln(1-a)$, $\\delta^3=\\frac1m(\\sum a^{(3)}-\\sum y)$.\n",
        "\n",
        "\n",
        "\n",
        ":::\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "## Example\n",
        "\n",
        "Let us take some of our old dataset as an example. This is an continuation of the horse colic dataset from Logistic regression.\n"
      ],
      "id": "69bb790e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pandas as pd\n",
        "import numpy as np\n",
        "\n",
        "url = 'http://archive.ics.uci.edu/ml/machine-learning-databases/horse-colic/horse-colic.data'\n",
        "df = pd.read_csv(url, delim_whitespace=True, header=None)\n",
        "df = df.replace(\"?\", np.NaN)\n",
        "\n",
        "df.fillna(0, inplace=True)\n",
        "df.drop(columns=[2, 24, 25, 26, 27], inplace=True)\n",
        "df[23].replace({1: 1, 2: 0}, inplace=True)\n",
        "X = df.iloc[:, :-1].to_numpy().astype(float)\n",
        "y = df[23].to_numpy().astype(int)\n",
        "\n",
        "from sklearn.model_selection import train_test_split\n",
        "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.15, random_state=42)\n",
        "\n",
        "from sklearn.preprocessing import MinMaxScaler\n",
        "\n",
        "mms = MinMaxScaler()\n",
        "mms.fit(X_train)\n",
        "X_train = mms.transform(X_train)\n",
        "X_test = mms.transform(X_test)"
      ],
      "id": "6de2145b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now we build a neural network. This is a 2-layer model, with 1 hidden layer with 10 nodes.\n"
      ],
      "id": "3cd42fe0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "#| warning: false\n",
        "# import keras_core as keras\n",
        "from keras import models, layers, Input\n",
        "model = models.Sequential()\n",
        "\n",
        "model.add(Input(shape=(X_train.shape[1],)))\n",
        "model.add(layers.Dense(10, activation='sigmoid'))\n",
        "model.add(layers.Dense(1, activation='sigmoid'))\n",
        "\n",
        "model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])\n",
        "hist = model.fit(X_train, y_train, epochs=500, batch_size=30, validation_data=(X_test, y_test), verbose=0)\n",
        "\n",
        "loss_train = hist.history['loss']\n",
        "loss_val = hist.history['val_loss']\n",
        "\n",
        "acc_train = hist.history['accuracy']\n",
        "acc_val = hist.history['val_accuracy']"
      ],
      "id": "813ac286",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "And the learning curve are shown in the following plots.\n"
      ],
      "id": "bf895a4d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import matplotlib.pyplot as plt\n",
        "fig, ax = plt.subplots(1, 2)\n",
        "ax[0].plot(loss_train, label='train_loss')\n",
        "ax[0].plot(loss_val, label='val_loss')\n",
        "ax[0].legend()\n",
        "\n",
        "ax[1].plot(acc_train, label='train_acc')\n",
        "ax[1].plot(acc_val, label='val_acc')\n",
        "ax[1].legend()"
      ],
      "id": "b5fe863e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "It seems that our model has overfitting issues. Therefore we need to modifify the architects of our model. The first idea is to add `L2` regularization as we talked about it in LogsiticRegression case. Here we use `0.01` as the regularization strenth.\n",
        "\n",
        "Let us add the layer to the model and retrain it.\n"
      ],
      "id": "62822163"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "#| warning: false\n",
        "# import keras_core as keras\n",
        "from keras import regularizers\n",
        "model = models.Sequential()\n",
        "\n",
        "model.add(layers.Dense(10, activation='sigmoid', input_dim=X_train.shape[1], kernel_regularizer=regularizers.l2(0.01)))\n",
        "model.add(layers.Dense(1, activation='sigmoid', kernel_regularizer=regularizers.l2(0.01)))\n",
        "\n",
        "model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])\n",
        "hist = model.fit(X_train, y_train, epochs=500, batch_size=30, validation_data=(X_test, y_test), verbose=0)\n",
        "\n",
        "loss_train = hist.history['loss']\n",
        "loss_val = hist.history['val_loss']\n",
        "\n",
        "acc_train = hist.history['accuracy']\n",
        "acc_val = hist.history['val_accuracy']"
      ],
      "id": "c705d851",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import matplotlib.pyplot as plt\n",
        "fig, ax = plt.subplots(1, 2)\n",
        "ax[0].plot(loss_train, label='train_loss')\n",
        "ax[0].plot(loss_val, label='val_loss')\n",
        "ax[0].legend()\n",
        "\n",
        "ax[1].plot(acc_train, label='train_acc')\n",
        "ax[1].plot(acc_val, label='val_acc')\n",
        "ax[1].legend()"
      ],
      "id": "1c72a5da",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Another way to deal with overfitting is to add a `Dropout` layer. The idea is that when training the model, part of the data will be randomly discarded. Then after fitting, the model tends to reduce the variance, and then reduce the overfitting. \n",
        "\n",
        "The code of a `Dropout` layer is listed below. Note that the number represents the percentage of the training data that will be dropped.\n"
      ],
      "id": "79745ab0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "# import keras_core as keras\n",
        "from keras import regularizers\n",
        "model = models.Sequential()\n",
        "\n",
        "model.add(layers.Dense(10, activation='sigmoid', input_dim=X_train.shape[1]))\n",
        "model.add(layers.Dropout(0.3))\n",
        "model.add(layers.Dense(1, activation='sigmoid'))\n",
        "\n",
        "model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])\n",
        "hist = model.fit(X_train, y_train, epochs=500, batch_size=30, validation_data=(X_test, y_test), verbose=0)\n",
        "\n",
        "loss_train = hist.history['loss']\n",
        "loss_val = hist.history['val_loss']\n",
        "\n",
        "acc_train = hist.history['accuracy']\n",
        "acc_val = hist.history['val_accuracy']"
      ],
      "id": "700314e7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import matplotlib.pyplot as plt\n",
        "fig, ax = plt.subplots(1, 2)\n",
        "ax[0].plot(loss_train, label='train_loss')\n",
        "ax[0].plot(loss_val, label='val_loss')\n",
        "ax[0].legend()\n",
        "\n",
        "ax[1].plot(acc_train, label='train_acc')\n",
        "ax[1].plot(acc_val, label='val_acc')\n",
        "ax[1].legend()"
      ],
      "id": "33377b57",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "After playing with different hyperparameters, the overfitting issues seem to be better (but not entirely fixed). However, the overall performance is getting worse. This means that the model is moving towards underfitting side. Then we may add more layers to make the model more complicated in order to capture more information.\n"
      ],
      "id": "f30d1a94"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "# import keras_core as keras\n",
        "from keras import regularizers\n",
        "model = models.Sequential()\n",
        "\n",
        "model.add(layers.Dense(10, activation='sigmoid', input_dim=X_train.shape[1]))\n",
        "model.add(layers.Dropout(0.3))\n",
        "model.add(layers.Dense(10, activation='sigmoid', input_dim=X_train.shape[1]))\n",
        "model.add(layers.Dropout(0.1))\n",
        "model.add(layers.Dense(1, activation='sigmoid'))\n",
        "\n",
        "model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])\n",
        "hist = model.fit(X_train, y_train, epochs=500, batch_size=30, validation_data=(X_test, y_test), verbose=0)\n",
        "\n",
        "loss_train = hist.history['loss']\n",
        "loss_val = hist.history['val_loss']\n",
        "\n",
        "acc_train = hist.history['accuracy']\n",
        "acc_val = hist.history['val_accuracy']"
      ],
      "id": "1240763e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import matplotlib.pyplot as plt\n",
        "fig, ax = plt.subplots(1, 2)\n",
        "ax[0].plot(loss_train, label='train_loss')\n",
        "ax[0].plot(loss_val, label='val_loss')\n",
        "ax[0].legend()\n",
        "\n",
        "ax[1].plot(acc_train, label='train_acc')\n",
        "ax[1].plot(acc_val, label='val_acc')\n",
        "ax[1].legend()"
      ],
      "id": "07b80f73",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "As you may see, to build a netural network model it requires many testing. There are many established models. When you build your own architecture, you may start from there and modify it to fit your data.\n",
        "\n",
        "\n",
        "## Exercises and Projects\n",
        "\n",
        "\n",
        "::: {#exr-}\n",
        "Please hand write a report about the details of back propagation.\n",
        "\n",
        ":::\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "::: {#exr-}\n",
        "CHOOSE ONE: Please use netural network to one of the following datasets. \n",
        "- the `iris` dataset.\n",
        "- the dating dataset.\n",
        "- the `titanic` dataset.\n",
        "\n",
        "Please in addition answer the following questions.\n",
        "\n",
        "1. What is your accuracy score?\n",
        "2. How many epochs do you use?\n",
        "3. What is the batch size do you use?\n",
        "4. Plot the learning curve (loss vs epochs, accuracy vs epochs).\n",
        "5. Analyze the bias / variance status.\n",
        "\n",
        ":::\n"
      ],
      "id": "b49b2de4"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\Xinli\\miniforge3\\envs\\ds25\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}