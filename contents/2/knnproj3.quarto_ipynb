{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## k-NN Project 3: Handwritten recognition\n",
        "\n",
        "We would like to let the machine recognize handwritten digits. The dataset is MNIST comeing from the [MNIST database](https://yann.lecun.com/exdb/mnist/). Now we apply kNN algrotithm to it. \n",
        "\n",
        "### Dataset description\n",
        "Every digit is stored as a $28\\times28$ picture. This is a $28\\times28$ matrix. Every entry represents a gray value of the corresponding pixel, whose value is from 0 to 255. The label of each matrix is the digit it represents. Note that the dataset provided is already splitted into a training set and a test set.\n",
        "\n",
        "The dataset can be loaded following the [instruction](https://xiaoxl.github.io/Datasets/contents/mnist.html).\n"
      ],
      "id": "cad5a8e4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from datasets import load_dataset\n",
        "import numpy as np\n",
        "import itertools\n",
        "\n",
        "def stream_to_array(streaming, max=None):\n",
        "    pic_list = []\n",
        "    label_list =[]\n",
        "    if max is None:\n",
        "        generator = streaming\n",
        "    else:\n",
        "        generator = itertools.islice(streaming, max)\n",
        "    for data in generator:\n",
        "        pic_list.append(np.array(data['image']).reshape(-1))\n",
        "        label_list.append(data['label'])\n",
        "    return np.array(pic_list), np.array(label_list)\n",
        "\n",
        "mnist_train = load_dataset(\"ylecun/mnist\", split='train', streaming=True)\n",
        "mnist_test = load_dataset(\"ylecun/mnist\", split='test', streaming=True)\n",
        "\n",
        "X_train, y_train = stream_to_array(mnist_train, max=600)\n",
        "X_test, y_test = stream_to_array(mnist_test, max=100)"
      ],
      "id": "339be8a3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note that one of the purpose to load the data in streaming mode is that the dataset is big and it is not wise to load everything all together. However this is the only way to train a KNN model since all it does is to memorize everything. In the future with other models we may want to load the image one by one with the streaming mode.\n",
        "\n",
        "Also due to the issue of large dataset, I only choose the first 600/100 images from the original dataset. The `itertools.islice` is used to only choose the first few items from a generator. We may also check the distribution of `y`. \n"
      ],
      "id": "59ae526a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "np.unique(y_train, return_counts=True)"
      ],
      "id": "983c8f63",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Although not optimal, all digits are presented, and the distributions are relatively equal. So we will use this slice of the original dataset. In reality, if possible it is always better to use all data provided to you.\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "### Apply k-NN\n",
        "Like the previous two examples, we now try to apply the k-NN algorithm to classify these handwritten digits. Note that the original dataset is huge and the processing time is very slow. However since we only choose 600/100 images, we could still run all our tricks. \n"
      ],
      "id": "d75315c5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from sklearn.pipeline import Pipeline\n",
        "from sklearn.preprocessing import MinMaxScaler\n",
        "from sklearn.neighbors import KNeighborsClassifier\n",
        "from sklearn.model_selection import cross_val_score\n",
        "from sklearn.base import clone\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "steps = [('scaler', MinMaxScaler()),\n",
        "         ('knn', KNeighborsClassifier(n_neighbors=5))]\n",
        "pipe = Pipeline(steps=steps)\n",
        "n_list = list(range(1, 11))\n",
        "\n",
        "cv_score = []\n",
        "for k in n_list:\n",
        "    pipe_tmp = clone(pipe)\n",
        "    pipe_tmp.set_params(knn__n_neighbors=k)\n",
        "    cv_score.append(cross_val_score(pipe_tmp, X_train, y_train, cv=5).mean())\n",
        "plt.plot(n_list, cv_score)"
      ],
      "id": "e4bfada6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from sklearn.model_selection import GridSearchCV\n",
        "\n",
        "gs = GridSearchCV(pipe, param_grid=dict(knn__n_neighbors=n_list), cv=5)\n",
        "gs.fit(X_train, y_train)\n",
        "gs.best_params_"
      ],
      "id": "cd4ff9f5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The best `k` is 3 for this degenerated dataset. The corresponding test score is \n"
      ],
      "id": "a2d3bdcf"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "gs.score(X_test, y_test)"
      ],
      "id": "65a5d750",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\Xinli\\miniforge3\\envs\\ds25\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}